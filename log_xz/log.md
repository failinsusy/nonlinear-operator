# 一种硬件友好的高精度对数算子计算方法
## 计算思路
##### 对数运算可以被拆解为以下形式：

$$
\log_ax=\frac{\log_bx}{\log_ba}（b为新底数，一般取2或e）
$$
##### 然而除法运算在硬件设备中资源占用量很大，因此考虑用乘法运算代替除法运算，即：
$$
\frac{\log_bx}{\log_ba}=\log_bx\times\log_ab
$$
##### 其中，在处理$\log_a2$(或$\log_ae$)时，我们可以选取一系列常用的底数a（如e等），事先计算出一系列$\log_a2$（或$\log_ae$）的值并储存在LUT中。这一操作可以极大减轻硬件负担。
##### 以$\log_a2$为例：
$$
\log_32 ≈ (0.10100001100000101)_2\\
\log_52 ≈ (0.011011100100001001)_2\\
\log_62 ≈ (0.011000110000101)_2\\
\log_72 ≈ (0.0101101100101)_2\\
\log_82 ≈ (0.010101010101)_2\\
\log_92 ≈ (0.01010000110001)_2\\
\log_e2 ≈ (0.1011000101101)_2\\
$$
##### 基于以上操作，我们可以通过基本的加减法和移位操作完成$\log_bx\times\log_ab$的计算。
##### 例如计算$\log_2x\times\log_32$时，
$$
Result = (log2b >> 1) + (log2b >> 3) + (log2b >>
8)\\ + (log2b >> 9) + (log2b >> 15) + (log2b >> 17) 
$$
##### 对于$\log_bx$，我们显然希望自变量的取值范围尽可能小，这样在进行拟合时（无论是采用分段拟合还是泰勒展式拟合）精度才足够高。我们可以利用浮点数的概念对其进行变换，以将自变量的范围约束在$[1,2]$乃至更小的集合中。
##### 以32位浮点数为例，它由符号位f（1位）、阶数j（8位）和尾数m（23位）构成，即：
$$
x=(-1)^f\times2^{j-127}\times m
$$

##### 由于对数函数中自变量一定为正，则：
$$
x=2^{j-127}\times m
$$
##### 带入对数函数中可以得到
$$
\log_bx=log_b(m\times2^{j-127})=log_bm+(j-127)\times log_b2
$$
##### 令显然对于一个确定的浮点数，其阶数j是定值。只要事先计算出log_b2的值，上式的最后一项可视为常数C，即：
$$
\log_bx=\log_bm+N（1<m<2）
$$
##### 计算出$log_bm$的值即可。
##### 由此，我们可以得到一个完善的对数算子计算流程，软件实现如下（包含了提取x作为浮点数的阶数j和尾数m的过程）：
```
#include<stdio.h>
#include <math.h>

float my_log(float x){
	float ln_2 = 0.693147;		// ln(2) = 0.693147
	int i_x = *(int*)&x;
	int x_j = ((i_x & 0x7f800000) >> 23) - 127;
	int x_m = (i_x & 0x007fffff) | 0x3f800000;
	float m = *(float*)&x_m;
	m *= 0.707106;				// sqrt(2) / 2 = 0.707106
	m -= 1.0;
	float t_m = m * m;
	float k = 1.0;
	float result = m;
	for (int i = 2; i < 8; i++){
		k = -1.0 * k;
		result += k * t_m / (1.0 * i);
		t_m *= m;
	}
	return x_j * ln_2 + 0.5 * ln_2 + result;
}
int main(){
	for (int i = 1; i <= 30; i++){
		float x = i * 0.2;
		printf("x = %2.6f, my log(x) = %2.6f, log(x) = %2.6f, err = %2.6f\n", x, my_log(x), log(x), fabs(my_log(x) - log(x)));
	}
	return 0;
}
```
##### 接下来有两种方法完成剩余计算。
##### 一、PWL分段拟合法
##### 分段线性（PWL）方法是一种通过将复杂非线性函数分割为多个线性段进行近似处理的技术。在计算$log_bm$，我们可以将输入范围$[1,2]$划分为多个区间，每个区间用线性方程$y=k_i+b_i$近似原函数，并将每个区间的斜率$k_i$和截距$b_i$储存在LUT中。
##### 示例：在$[1,2]$上分4段拟合计算$log_bm$。Verilog代码如下：
```
module log2_pwl (
    input  wire clk,          // 时钟
    input  wire [15:0] x_Q8,  // 输入x（Q8.8格式，范围1.0 ≤ x < 2.0）
    output reg  [15:0] y_Q4   // 输出log2(x)（Q4.12格式）
);

// 定义分段区间边界（Q8.8格式）
localparam [15:0] SEG1 = 16'h2000; // 1.25 = 1.25 * 256 = 0x2000
localparam [15:0] SEG2 = 16'h3000; // 1.5  = 1.5  * 256 = 0x3000
localparam [15:0] SEG3 = 16'h3800; // 1.75 = 1.75 * 256 = 0x3800

// 定义LUT（斜率k_i和截距b_i，Q4.12格式）
reg [15:0] k, b;
always @(*) begin
    if (x_Q8 < SEG1) begin        // 1.0 ≤ x < 1.25
        k = 16'h06A4;  // 0.4150
        b = 16'hF95C;  // -0.4150
    end else if (x_Q8 < SEG2) begin // 1.25 ≤ x < 1.5
        k = 16'h0525;  // 0.3219
        b = 16'hFE6E;  // -0.1964
    end else if (x_Q8 < SEG3) begin // 1.5 ≤ x < 1.75
        k = 16'h0434;  // 0.2630
        b = 16'hFFD5;  // -0.0586
    end else begin                // 1.75 ≤ x < 2.0
        k = 16'h038D;  // 0.2223
        b = 16'h0030;  // 0.0469
    end
end

// 计算 y = k*x + b（使用流水线乘加）
reg [31:0] mult_result;
always @(posedge clk) begin
    mult_result <= k * x_Q8;  // 乘法（Q4.12 * Q8.8 = Q12.20）
end

always @(posedge clk) begin
    // 加法（截断为Q4.12，注意符号扩展）
    y_Q4 <= (mult_result[31:8] + { {4{b[15]}}, b[15:4] }) >> 8;
end

endmodule
```
##### 实际使用时，可以提高分段数（一般分32段）以提高计算精度。后续优化时，可以根据log函数特性采用自适应分段，提高拟合精确度。
##### 二、泰勒展开法
##### 我们注意到，当$\log_bx$取底数$x=e$时，$\ln x$在[1,2]的区间上可以很容易用泰勒展开的方式进行近似。由于泰勒展开在$x=1$附近拟合效果最好，可以先对自变量取值范围进行处理，例如：
$$
\ln m=\ln(\sqrt2\times\frac{\sqrt2}{2}\times m)=\frac{\ln2}{2}+\ln(\frac{\sqrt2}{2}m)
$$
##### 令$\frac{\sqrt2}{2}m=t$，则$t\in(\frac{\sqrt2}{2},\sqrt2)$，则进一步计算$\ln t$即可。这显然是一个更好的自变量区间。
##### 对$\ln t$在$t=1$处进行6阶展开，得到以下公式。
$$
\ln t=(t-1)-\frac{(t-1)^2}{2}+\frac{(t-1)^3}{3}-\frac{(t-1)^4}{4}+\frac{(t-1)^5}{5}-\frac{(t-1)^6}{6}
$$
##### 注意到上式右边从第二项开始的每一项均可以用前一项迭代，并且除法操作可以用乘法和移位操作取代，这样可以优化硬件资源的占用。因此上式可以表示为：
$$
\ln t=a-(a>>1)+0.3333\times ab-(ac>>2)+0.2\times ad-0.1667\times ae
$$
##### 依照以上公式带值计算即可。
